# Lab 8: 文件系统上层抽象 实验报告

## 系统设计部分

### 架构设计说明

本实验在基础的文件系统底层（块设备驱动、缓冲区缓存、位图管理）之上，实现了文件系统的高层抽象。整体架构采用分层设计，自底向上依次为：

1.  **Inode 层 (`kernel/fs/inode.c`)**：
    *   负责管理文件的元数据（Metadata），如文件类型、大小、链接数以及数据块索引。
    *   实现了文件逻辑偏移量到物理磁盘块号的映射（`inode_read_data`/`inode_write_data`）。
    *   维护内存中的 Inode 缓存（`icache`），处理 Inode 的分配、释放、引用计数和同步。

2.  **目录层 (`kernel/fs/dir.c`)**：
    *   将目录视为一种特殊的文件，其数据内容为一系列目录项（`dirent_t`）。
    *   提供了对目录项的增删改查接口（`dir_search_entry`, `dir_add_entry`, `dir_delete_entry`）。
    *   实现了目录项与 Inode 编号的绑定。

3.  **路径解析层 (`kernel/fs/dir.c`)**：
    *   负责将人类可读的路径字符串（如 `/home/user/file`）解析为对应的 Inode。
    *   实现了路径遍历逻辑（`path_to_inode`），处理多级目录查找。
    *   提供了基于路径的文件操作接口，如创建文件（`path_create_inode`）、创建链接（`path_link`）、删除链接（`path_unlink`）。

### 关键数据结构

1.  **内存 Inode (`inode_t`)**：
    *   包含磁盘 Inode 的副本（`type`, `size`, `addrs` 等）。
    *   增加了内存管理字段：
        *   `ref`: 引用计数，记录有多少个指针（如进程打开文件表、路径解析过程中的临时变量）指向该 Inode。
        *   `slk`: 睡眠锁，保护 Inode 内容的互斥访问。
        *   `valid`: 标记内存副本是否已从磁盘同步。

2.  **目录项 (`dirent_t`)**：
    *   结构简单，固定大小（32字节）。
    *   `uint16 inode_num`: 指向文件的 Inode 编号。
    *   `char name[30]`: 文件名。
    *   设计决策：采用固定大小的目录项简化了目录文件的管理，使得可以通过偏移量直接计算目录项位置。

### 与 xv6 对比分析

*   **锁机制**：与 xv6 类似，使用了两层锁机制。`icache` 锁（自旋锁）保护 Inode 的分配和引用计数，`inode` 锁（睡眠锁）保护 Inode 的具体内容。这允许在持有 Inode 引用时（`ref > 0`）不持有内容锁，提高了并发性能。
*   **路径解析**：采用了与 xv6 相同的 `skipelem` 算法来逐级解析路径。
*   **差异点**：
    *   本实验中对目录大小做了简化假设（一个目录仅占用一个 Block），而 xv6 支持多 Block 目录。
    *   在 `inode_rw` 中显式区分了读写操作，增强了数据同步的可控性。

### 设计决策理由

1.  **先获取子节点引用再释放父节点锁**：
    *   在路径解析（`path_to_inode`）中，必须在释放父目录锁之前，先通过 `inode_alloc` 获取子节点的引用（`ref++`）。
    *   **理由**：防止竞态条件。如果先释放父锁，其他进程可能会在当前进程获取子节点引用之前，删除该子节点或重用该 Inode 编号，导致当前进程访问到错误或无效的对象。

2.  **错误处理中的资源清理**：
    *   在 `path_create_inode` 中，如果 `dir_add_entry` 失败，必须手动将新创建的 Inode 的 `nlink` 置为 0 并释放。
    *   **理由**：防止 Inode 泄露。虽然内存引用会被释放，但如果磁盘上的 `nlink` 保持为 1 且未被任何目录引用，该 Inode 将永远无法被回收（孤儿 Inode）。

## 实验过程部分

### 实现步骤记录

1.  **Inode 层实现**：
    *   实现了 `inode_read_data` 和 `inode_write_data`。核心逻辑是利用 `inode_locate_block` 将文件内的逻辑偏移量转换为磁盘块号，然后通过 Buffer Cache 读写数据。
    *   处理了跨 Block 的读写操作，确保数据在 Block 边界处正确衔接。

2.  **目录管理实现**：
    *   `dir_search_entry`：遍历目录 Block 中的所有 `dirent_t`，比较文件名。
    *   `dir_add_entry`：优先查找 `INODE_NUM_UNUSED` 的空位进行复用；若无空位则追加到文件末尾。同时处理了目录大小（`size`）的更新。
    *   `dir_delete_entry`：将目标目录项的 `inode_num` 标记为 `INODE_NUM_UNUSED`，实现逻辑删除。

3.  **路径解析实现**：
    *   `path_to_inode` / `path_to_pinode`：循环调用 `skip_element` 和 `dir_search_entry`。
    *   `path_create_inode`：组合了 `path_to_pinode`（找父目录）、`inode_create`（分配 Inode）和 `dir_add_entry`（链接到目录）。
    *   `path_link` / `path_unlink`：实现了硬链接的创建和删除，重点维护了 `nlink` 计数的正确性。

### 问题与解决方案

*   **问题1：死锁风险**
    *   **场景**：在 `path_create_inode` 中，持有父目录锁的同时尝试获取新 Inode 的锁。
    *   **解决方案**：严格遵守锁顺序。在 `inode_create` 内部，获取新 Inode 锁之前不需要父目录锁（因为是新分配的）。但在将新 Inode 链接到目录时，需要持有父目录锁。如果操作失败需要清理，必须小心释放锁的顺序，防止死锁。

*   **问题2：路径解析中的锁释放时机**
    *   **场景**：在遍历路径时，如何安全地从父目录切换到子目录。
    *   **解决方案**：采用“交接”模式。
        ```c
        next = inode_alloc(inum); // 1. 增加子节点引用
        inode_unlock(ip);         // 2. 释放父节点锁
        inode_free(ip);           // 3. 释放父节点引用
        ip = next;                // 4. 切换
        ```

*   **问题3：新文件创建失败的清理**
    *   **场景**：`inode_create` 成功但 `dir_add_entry` 失败（如目录满）。
    *   **解决方案**：此时新 Inode 的 `nlink` 默认为 1。需要显式将其 `nlink` 改为 0 并同步到磁盘，然后释放内存引用，以便系统回收该 Inode。

### 源码理解总结

通过本实验，深入理解了文件系统的“索引”思想。Inode 是文件系统的核心枢纽，它解耦了文件名（由目录层管理）和文件数据（由 Block 层管理）。路径解析本质上是一个在目录树图上的遍历过程，而锁机制则是保证这个遍历过程在并发环境下原子性和一致性的关键。

## 测试验证部分

### 功能测试结果

1.  **文件创建与读写**：
    *   能够通过 `path_create_inode` 创建新文件。
    *   能够通过 `inode_write_data` 写入数据，并通过 `inode_read_data` 正确读回。
2.  **目录操作**：
    *   能够在一个目录下创建多个文件。
    *   `dir_search_entry` 能正确找到已存在的文件。
    *   `dir_delete_entry` 能正确删除文件，且再次查找返回未找到。
3.  **硬链接**：
    *   `path_link` 成功创建了指向同一 Inode 的新目录项。
    *   `path_unlink` 删除链接后，文件数据仍然存在，直到最后一个链接被删除。

### 异常测试

1.  **重复创建文件**：
    *   尝试创建已存在的文件名，`path_create_inode` 正确返回了已存在的 Inode（或根据语义报错），未导致数据覆盖或 Inode 泄露。
2.  **删除非空目录**：
    *   虽然本实验主要关注文件 unlink，但逻辑上 `check_unlink`（如果实现）应阻止删除非空目录，防止目录树断裂。
3.  **路径不存在**：
    *   访问不存在的路径（如 `/a/b/c` 中 `b` 不存在），`path_to_inode` 正确返回 NULL。

### 运行截图/录屏

*(此处应插入 QEMU 运行截图，展示文件系统初始化成功，以及相关测试用例通过的终端输出)*
